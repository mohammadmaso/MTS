/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/js-graph-algorithms/src/jsgraphs.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-graph-algorithms/src/jsgraphs.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var jsgraphs = jsgraphs || {};\r\n\r\n(function(jss){\r\n    \r\n    jss.less = function(a1, a2, compare) {\r\n        return compare(a1, a2) < 0;\r\n    };\r\n    \r\n    jss.exchange = function(a, i, j) {\r\n        var temp = a[i];\r\n        a[i] = a[j];\r\n        a[j] = temp;\r\n    };\r\n    \r\n    var StackNode = function (value) {\r\n        this.value = value;\r\n        this.next = null;\r\n    };\r\n    \r\n    jss.StackNode = StackNode;\r\n    \r\n    var Stack = function() {\r\n        this.N = 0;\r\n        this.first = null;\r\n    };\r\n    \r\n    Stack.prototype.push = function (a) {\r\n        this.first = this._push(this.first, a);  \r\n    };\r\n    \r\n    Stack.prototype._push = function(x, a) {\r\n        if(x == null) {\r\n            this.N++;\r\n            return new jss.StackNode(a);\r\n        }  \r\n        var oldX = x;\r\n        this.N++;\r\n        x = new jss.StackNode(a);\r\n        x.next = oldX;\r\n        return x;\r\n    };\r\n    \r\n    Stack.prototype.pop = function () {\r\n        if (this.first == null) {\r\n            return undefined;\r\n        }  \r\n        \r\n        var oldFirst = this.first;\r\n        var item = oldFirst.value;\r\n        this.first = oldFirst.next;\r\n        this.N--;\r\n        \r\n        return item;\r\n    };\r\n    \r\n    Stack.prototype.size = function() {\r\n        return this.N;  \r\n    };\r\n    \r\n    Stack.prototype.isEmpty = function() {\r\n        return this.N == 0;  \r\n    };\r\n    \r\n    Stack.prototype.peep = function() {\r\n        if (this.first == null) {\r\n            return undefined;\r\n        }  \r\n        \r\n        return this.first.value;\r\n    };\r\n    \r\n    Stack.prototype.toArray = function() {\r\n        var result = [];\r\n        x = this.first;\r\n        while (x != null) {\r\n            result.push(x.value);\r\n            x = x.next;\r\n        }\r\n        return result;\r\n    };\r\n    \r\n    jss.Stack = Stack;\r\n    \r\n    var QueueNode = function(a) {\r\n        this.value = a;  \r\n        this.next = null;\r\n    };\r\n    \r\n    jss.QueueNode = QueueNode;\r\n    \r\n    var Queue = function() {\r\n        this.first = null;\r\n        this.last = null;\r\n        this.N = 0;\r\n    };\r\n    \r\n    Queue.prototype.enqueue = function(item) {\r\n        var oldLast = this.last;\r\n        this.last = new jss.QueueNode(item);\r\n        if(oldLast != null){\r\n            oldLast.next = this.last;\r\n        }\r\n        if (this.first == null) {\r\n            this.first = this.last;\r\n        }\r\n        this.N++;\r\n    };\r\n    \r\n    Queue.prototype.dequeue = function() {\r\n        if(this.first == null) {\r\n            return undefined;\r\n        }  \r\n        \r\n        var oldFirst = this.first;\r\n        var item = oldFirst.value;\r\n        this.first = oldFirst.next;\r\n        \r\n        if(this.first == null) {\r\n            this.last = null;\r\n        }\r\n        \r\n        this.N--;\r\n        \r\n        return item;\r\n    };\r\n    \r\n    Queue.prototype.size = function() {\r\n        return this.N;  \r\n    };\r\n    \r\n    Queue.prototype.isEmpty = function() {\r\n        return this.N == 0;\r\n    };\r\n    \r\n    Queue.prototype.toArray = function() {\r\n        var result = [];\r\n        var x = this.first;\r\n        while (x != null) {\r\n            result.push(x.value);\r\n            x = x.next;\r\n        }\r\n        return result;\r\n    };\r\n    \r\n    jss.Queue = Queue;\r\n    \r\n    var MinPQ = function(compare) {\r\n        this.s = [];\r\n        this.N = 0;\r\n        if(!compare) {\r\n            compare = function(a1, a2) {\r\n                return a1 - a2;\r\n            };\r\n        }\r\n        this.compare = compare;\r\n    };\r\n    \r\n    MinPQ.prototype.enqueue = function(item) {\r\n        while(this.s.lengh <= this.N+1) {\r\n            this.s.push(0);\r\n        }   \r\n        this.s[++this.N] = item;\r\n        this.swim(this.N);\r\n    };\r\n    \r\n    MinPQ.prototype.swim = function(k) {\r\n        while (k > 1){\r\n            var parent = Math.floor(k / 2);\r\n            if(jss.less(this.s[k], this.s[parent], this.compare)){\r\n                jss.exchange(this.s, k, parent);\r\n                k = parent;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    \r\n    MinPQ.prototype.delMin = function() {\r\n        if(this.N == 0) {\r\n            return undefined;\r\n        }  \r\n        \r\n        var item = this.s[1];\r\n        jss.exchange(this.s, 1, this.N--);\r\n        this.sink(1);\r\n        return item;\r\n    };\r\n    \r\n    MinPQ.prototype.sink = function(k) {\r\n        while(k * 2 <= this.N) {\r\n            var child = 2 * k;\r\n            if(child < this.N && jss.less(this.s[child+1], this.s[child], this.compare)){\r\n                child++;\r\n            }\r\n            if(jss.less(this.s[child], this.s[k], this.compare)){\r\n                jss.exchange(this.s, child, k);\r\n                k = child;\r\n            } else {\r\n                break;\r\n            }\r\n        }  \r\n    };\r\n    \r\n    MinPQ.prototype.size = function(){\r\n        return this.N;\r\n    };\r\n    \r\n    MinPQ.prototype.isEmpty = function() {\r\n        return this.N == 0;\r\n    };\r\n    \r\n    jss.MinPQ = MinPQ;\r\n    \r\n    var QuickUnion = function(V) {\r\n        this.id = [];\r\n        for (var v = 0; v < V; ++v) {\r\n            this.id.push(v);\r\n        }\r\n    };\r\n    \r\n    QuickUnion.prototype.union = function(v, w) {\r\n        var q = this.root(v);\r\n        var p = this.root(w);\r\n        \r\n        if(p != q) {\r\n            this.id[p] = q;\r\n        }\r\n    };\r\n    \r\n    QuickUnion.prototype.root = function(q) {\r\n        while(this.id[q] != q) {\r\n            q = this.id[q];\r\n        }  \r\n        return q;\r\n    };\r\n    \r\n    QuickUnion.prototype.connected = function(v, w) {\r\n        return this.root(v) == this.root(w);  \r\n    };\r\n    \r\n    jss.QuickUnion = QuickUnion;\r\n    \r\n    var IndexMinPQ = function(N, compare) {\r\n        this.keys = [];\r\n        this.pq = [];\r\n        this.qp = []; // positions of key in pq\r\n        for(var i = 0; i <= N; ++i) {\r\n            this.keys.push(null);\r\n            this.pq.push(0);\r\n            this.qp.push(-1);\r\n        }\r\n        this.N = 0;\r\n        \r\n        if(!compare) {\r\n            compare = function(a1, a2) {\r\n                return a1 - a2;  \r\n            };\r\n        } \r\n        this.compare = compare;\r\n    };\r\n    \r\n    IndexMinPQ.prototype.insert = function (index, key) {\r\n        this.keys[index] = key;\r\n        \r\n        this.pq[++this.N] = index;\r\n        this.qp[index] = this.N;\r\n        this.swim(this.N);\r\n    };\r\n    \r\n    IndexMinPQ.prototype.decreaseKey = function(index, key) {\r\n        if(jss.less(key, this.keys[index], this.compare)){\r\n            this.keys[index] = key;\r\n            this.swim(this.qp[index]);\r\n        }\r\n    };\r\n    \r\n    IndexMinPQ.prototype.minKey = function() {\r\n        return this.keys[this.pq[1]];  \r\n    };\r\n    \r\n    IndexMinPQ.prototype.min = function() {\r\n        return this.pq[1];  \r\n    };\r\n    \r\n    IndexMinPQ.prototype.delMin = function() {\r\n        var key = this.pq[1];\r\n        jss.exchange(this.pq, 1, this.N);\r\n        this.qp[this.pq[1]] = 1;\r\n        \r\n        this.qp[this.pq[this.N]] = -1;\r\n        this.keys[this.pq[this.N]] = null;\r\n    \r\n        this.N--;\r\n        \r\n        this.sink(1);\r\n        \r\n        return key;\r\n    };\r\n    \r\n    IndexMinPQ.prototype.swim = function (k) {\r\n        while( k > 1) {\r\n            var parent = Math.floor(k / 2);\r\n            if(jss.less(this.keys[this.pq[k]], this.keys[this.pq[parent]], this.compare)){\r\n                jss.exchange(this.pq, k, parent);\r\n                this.qp[this.pq[k]] = k;\r\n                this.qp[this.pq[parent]] = parent;\r\n                k = parent;\r\n            } else {\r\n                break;\r\n            }\r\n        }  \r\n    };\r\n    \r\n    IndexMinPQ.prototype.sink = function (k) {\r\n        while(2 * k <= this.N) {\r\n            var child = k * 2;\r\n            if(child < this.N && jss.less(this.keys[this.pq[child+1]], this.keys[this.pq[child]], this.compare)){\r\n                child++;\r\n            }\r\n            if(jss.less(this.keys[this.pq[child]], this.keys[this.pq[k]], this.compare)) {\r\n                jss.exchange(this.pq, k, child);\r\n                this.qp[this.pq[k]] = k;\r\n                this.qp[this.pq[child]] = child;\r\n                k = child;\r\n            } else {\r\n                break;\r\n            }\r\n        }  \r\n    };\r\n    \r\n    IndexMinPQ.prototype.containsIndex = function (index) {\r\n        return this.qp[index] != -1;  \r\n    };\r\n    \r\n    IndexMinPQ.prototype.isEmpty = function() {\r\n        return this.N == 0;  \r\n    };\r\n    \r\n    IndexMinPQ.prototype.size = function() {\r\n        return this.N;\r\n    }\r\n    \r\n    jss.IndexMinPQ = IndexMinPQ;\r\n    \r\n\tvar Graph = function (V) {\r\n        this.V = V;\r\n        this.adjList = [];\r\n        this.nodeInfo = [];\r\n        this.edges = {};\r\n        for (var i = 0; i < V; ++i) {\r\n            this.adjList.push([]);\r\n            this.nodeInfo.push({});\r\n        }\r\n    };\r\n    \r\n    Graph.prototype.addEdge = function(v, w){\r\n        this.adjList[v].push(w);\r\n        this.adjList[w].push(v);\r\n        var edge_id = v + '_' + w;\r\n        if(v > w) {\r\n            edge_id = w + '_' + v;\r\n        }\r\n        this.edges[edge_id] = new jss.Edge(v, w, 0);\r\n    };\r\n    \r\n    Graph.prototype.adj = function(v) {\r\n        return this.adjList[v];  \r\n    };\r\n    \r\n    Graph.prototype.node = function(v) {\r\n        return this.nodeInfo[v];  \r\n    };\r\n    \r\n    Graph.prototype.edge = function(v, w) {\r\n        var edge_id = v + '_' + w;\r\n        if(v > w) {\r\n            edge_id = w + '_' + v;\r\n        }\r\n        if (edge_id in this.edges) {\r\n            return this.edges[edge_id];\r\n        }\r\n        return null;\r\n    };\r\n    \r\n    jss.Graph = Graph;\r\n    \r\n    var DiGraph = function(V) {\r\n        this.V = V;\r\n        this.adjList = [];\r\n        this.nodeInfo = [];\r\n        this.edges = {};\r\n        for (var v = 0; v < V; ++v){\r\n            this.adjList.push([]);\r\n            this.nodeInfo.push({});\r\n        }\r\n    };\r\n    \r\n    DiGraph.prototype.addEdge = function(v, w){\r\n        this.adjList[v].push(w);\r\n        var edge_id = v + '_' + w;\r\n        this.edges[edge_id] = new jss.Edge(v, w, 0);\r\n    };\r\n    \r\n    DiGraph.prototype.edge = function(v, w) {\r\n        var edge_id = v + '_' + w;\r\n        if(edge_id in this.edges) {\r\n            return this.edges[edge_id];\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n    \r\n    DiGraph.prototype.adj = function(v) {\r\n        return this.adjList[v];  \r\n    };\r\n    \r\n    DiGraph.prototype.node = function(v) {\r\n        return this.nodeInfo[v];  \r\n    };\r\n    \r\n    DiGraph.prototype.reverse = function(){\r\n        var g = new DiGraph(this.V);\r\n        for (var v = 0; v < this.V; ++v) {\r\n            var adj_v = this.adjList[v];\r\n            for (var i = 0; i < adj_v.length; ++i){\r\n                var w = adj_v[i];\r\n                g.addEdge(w, v);\r\n            }\r\n        }\r\n        return g;\r\n    };\r\n    \r\n    jss.DiGraph = DiGraph;\r\n    \r\n    var Edge = function(v, w, weight) {\r\n        this.v = v;\r\n        this.w = w;\r\n        this.weight = weight;\r\n    };\r\n    \r\n    Edge.prototype.either = function() {\r\n        return this.v;\r\n    };\r\n    \r\n    Edge.prototype.other = function(x) {\r\n        return x == this.v ? this.w : this.v;\r\n    };\r\n    \r\n    Edge.prototype.from = function() {\r\n        return this.v;\r\n    };\r\n    \r\n    Edge.prototype.to = function() {\r\n        return this.w;\r\n    };\r\n    \r\n    jss.Edge = Edge;\r\n    \r\n    var WeightedGraph = function(V) {\r\n        this.V = V;\r\n        this.adjList = [];\r\n        this.nodeInfo = [];\r\n        \r\n        for ( var v = 0; v < V; ++v) {\r\n            this.adjList.push([]);\r\n            this.nodeInfo.push({});\r\n        }\r\n    };\r\n    \r\n    WeightedGraph.prototype.adj = function(v) {\r\n        return this.adjList[v];  \r\n    };\r\n    \r\n    WeightedGraph.prototype.edge = function(v, w) {\r\n        var adj_v = this.adjList[v];\r\n        for(var i=0; i < adj_v.length; ++i) {\r\n            var x = adj_v[i].other(v);\r\n            if(x == w) {\r\n                return adj_v[i];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    \r\n    WeightedGraph.prototype.node = function(v) {\r\n        return this.nodeInfo[v];  \r\n    };\r\n    \r\n    WeightedGraph.prototype.addEdge = function(e) {\r\n        var v = e.either();\r\n        var w = e.other(v);\r\n        this.adjList[v].push(e);\r\n        this.adjList[w].push(e);\r\n    };\r\n    \r\n    jss.WeightedGraph = WeightedGraph;\r\n    \r\n    var WeightedDiGraph = function(V) {\r\n        WeightedGraph.call(this, V);\r\n    };\r\n    \r\n    WeightedDiGraph.prototype = Object.create(jss.WeightedGraph.prototype);\r\n    \r\n    WeightedDiGraph.prototype.addEdge = function(e) {\r\n        var v = e.from();\r\n        this.adjList[v].push(e);\r\n    };\r\n    \r\n    WeightedDiGraph.prototype.edge = function(v, w) {\r\n        var adj_v = this.adjList[v];\r\n        for(var i=0; i < adj_v.length; ++i) {\r\n            var x = adj_v[i].other(v);\r\n            if(x == w) {\r\n                return adj_v[i];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    \r\n    WeightedDiGraph.prototype.toDiGraph = function() {\r\n        var g = new jss.DiGraph(this.V);\r\n        for(var v = 0; v < this.V; ++v) {\r\n            var adj_v = this.adjList[v];\r\n            for (var i =0; i < adj_v.length; ++i) {\r\n                var e = adj_v[i];\r\n                var w = e.other(v);\r\n                g.addEdge(v, w);\r\n            }\r\n        }\r\n        return g;\r\n    };\r\n    \r\n    jss.WeightedDiGraph = WeightedDiGraph;\r\n    \r\n    var FlowEdge = function(v, w, capacity) {\r\n        this.v = v;\r\n        this.w = w;\r\n        this.capacity = capacity;\r\n        this.flow = 0;\r\n    };\r\n    \r\n    FlowEdge.prototype.residualCapacityTo = function (x) {\r\n        if(x == this.v) {\r\n            return this.flow;\r\n        } else {\r\n            return this.capacity - this.flow;\r\n        }\r\n    };\r\n    \r\n    FlowEdge.prototype.addResidualFlowTo = function (x, deltaFlow) {\r\n        if(x == this.v) {\r\n            this.flow -= deltaFlow;\r\n        } else if(x == this.w) {\r\n            this.flow += deltaFlow;\r\n        }\r\n    };\r\n    \r\n    FlowEdge.prototype.from = function() {\r\n        return this.v;\r\n    };\r\n    \r\n    FlowEdge.prototype.to = function() {\r\n        return this.w;\r\n    };\r\n    \r\n    FlowEdge.prototype.other = function(x) {\r\n        return x == this.v ? this.w : this.v;\r\n    }\r\n    \r\n    \r\n    jss.FlowEdge = FlowEdge;\r\n    \r\n    var FlowNetwork = function(V) {\r\n        this.V = V;\r\n        this.adjList = [];\r\n        this.nodeInfo = [];\r\n        for(var v = 0; v < V; ++v) {\r\n            this.adjList.push([]);\r\n            this.nodeInfo.push({});\r\n        }\r\n    };\r\n    \r\n    FlowNetwork.prototype.node = function(v) {\r\n        return this.nodeInfo[v];\r\n    };\r\n    \r\n    FlowNetwork.prototype.edge = function(v, w) {\r\n        var adj_v = this.adjList[v];\r\n        for(var i=0; i < adj_v.length; ++i) {\r\n            var x = adj_v[i].other(v);\r\n            if(x == w) {\r\n                return adj_v[i];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    \r\n    FlowNetwork.prototype.addEdge = function(e) {\r\n        var v = e.from();\r\n        this.adjList[v].push(e);\r\n        var w = e.other(v);\r\n        this.adjList[w].push(e);\r\n    };\r\n    \r\n    FlowNetwork.prototype.adj = function(v) {\r\n        return this.adjList[v];  \r\n    };\r\n    \r\n    jss.FlowNetwork = FlowNetwork;\r\n    \r\n    var DepthFirstSearch = function(G, s) {\r\n        this.s = s;\r\n        var V = G.V;\r\n        this.marked = [];\r\n        this.edgeTo = [];\r\n        for (var v = 0; v < V; ++v) {\r\n            this.marked.push(false);\r\n            this.edgeTo.push(-1);\r\n        }\r\n        \r\n        this.dfs(G, s);\r\n    };\r\n    \r\n    DepthFirstSearch.prototype.dfs = function (G, v) {\r\n        this.marked[v] = true;\r\n        var adj_v = G.adj(v);\r\n        for (var i = 0; i < adj_v.length; ++i){\r\n            var w = adj_v[i];\r\n            if (!this.marked[w]){\r\n                this.edgeTo[w] = v;\r\n                this.dfs(G, w);\r\n            }\r\n        }\r\n    };\r\n    \r\n    DepthFirstSearch.prototype.hasPathTo = function(v) {\r\n        return this.marked[v];\r\n    };\r\n    \r\n    DepthFirstSearch.prototype.pathTo = function(v) {\r\n        var path = new jss.Stack();\r\n        if(v == this.s) return [v];\r\n        \r\n        for(var x = v; x != this.s; x = this.edgeTo[x]) {\r\n            path.push(x);\r\n        }\r\n        path.push(this.s);\r\n        return path.toArray();\r\n    };\r\n    \r\n    jss.DepthFirstSearch = DepthFirstSearch;\r\n    \r\n    var BreadthFirstSearch = function(G, s) {\r\n        var V = G.V;\r\n        this.s = s;\r\n        \r\n        var queue = new jss.Queue();\r\n        queue.enqueue(s);\r\n        this.marked = [];\r\n        this.edgeTo = [];\r\n        \r\n        for(var v = 0; v < V; ++v) {\r\n            this.marked.push(false);\r\n            this.edgeTo.push(-1);\r\n        }\r\n        \r\n        while (!queue.isEmpty()) {\r\n            var v = queue.dequeue();\r\n            this.marked[v] = true;\r\n            var adj_v = G.adj(v);\r\n            for (var i = 0; i < adj_v.length; ++i) {\r\n                var w = adj_v[i];\r\n                if(!this.marked[w]){\r\n                    this.edgeTo[w] = v;\r\n                    queue.enqueue(w);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    \r\n    BreadthFirstSearch.prototype.hasPathTo = function(v) {\r\n        return this.marked[v];\r\n    };\r\n    \r\n    BreadthFirstSearch.prototype.pathTo = function(v) {\r\n        var path = new jss.Stack();\r\n        if(v == this.s) return [v];\r\n        \r\n        for(var x = v; x != this.s; x = this.edgeTo[x]) {\r\n            path.push(x);\r\n        }\r\n        path.push(this.s);\r\n        return path.toArray();\r\n    };\r\n    \r\n    jss.BreadthFirstSearch = BreadthFirstSearch;\r\n    \r\n    var ConnectedComponents = function(G) {\r\n        this.count = 0;\r\n        var V = G.V;\r\n        this.marked = [];\r\n        this.id = [];\r\n        for (var v = 0; v < V; ++v) {\r\n            this.marked.push(false);\r\n            this.id.push(-1);\r\n        }\r\n        \r\n        for (var v = 0; v < V; ++v) {\r\n            if(!this.marked[v]){\r\n                this.dfs(G, v);\r\n                this.count++;\r\n            }\r\n        }\r\n    };\r\n    \r\n    ConnectedComponents.prototype.dfs = function(G, v) {\r\n        this.marked[v] = true;\r\n        this.id[v] = this.count;\r\n        var adj_v = G.adj(v);\r\n        \r\n        for(var i = 0; i < adj_v.length; ++i){\r\n            var w = adj_v[i];\r\n            if(!this.marked[w]){\r\n                this.dfs(G, w);\r\n            }\r\n        }\r\n    };\r\n    \r\n    ConnectedComponents.prototype.componentId = function(v) {\r\n        return this.id[v];\r\n    };\r\n    \r\n    ConnectedComponents.prototype.componentCount = function(){\r\n        return this.count;\r\n    };\r\n    \r\n    \r\n    jss.ConnectedComponents = ConnectedComponents;\r\n    \r\n    var TopologicalSort = function(G) {\r\n        this.postOrder = new jss.Stack();\r\n        this.marked = [];\r\n        var V = G.V;\r\n        for (var v = 0; v < V; ++v) {\r\n            this.marked.push(false);\r\n        }\r\n        \r\n        for (var v = 0; v < V; ++v) {\r\n            if(!this.marked[v]) {\r\n                this.dfs(G, v);\r\n            }\r\n        }\r\n    };\r\n    \r\n    TopologicalSort.prototype.dfs = function(G, v) {\r\n        this.marked[v] = true;\r\n        var adj_v = G.adj(v);\r\n        for (var i = 0; i < adj_v.length; ++i) {\r\n            var w = adj_v[i];\r\n            if(!this.marked[w]){\r\n                this.dfs(G, w);\r\n            }\r\n        }\r\n        this.postOrder.push(v);\r\n    };\r\n    \r\n    TopologicalSort.prototype.order = function() {\r\n        return this.postOrder.toArray();  \r\n    };\r\n    \r\n    jss.TopologicalSort = TopologicalSort;\r\n    \r\n    var StronglyConnectedComponents = function(G) {\r\n        var V = G.V;\r\n        this.count = 0;\r\n        this.marked = [];\r\n        this.id = [];\r\n        \r\n        for(var v = 0; v < V; ++v) {\r\n            this.marked.push(false);\r\n            this.id.push(-1);\r\n        }\r\n        \r\n        var order = new jss.TopologicalSort(G.reverse()).order();\r\n        for( var i = 0; i < order.length; ++i) {\r\n            var v = order[i];\r\n            if(!this.marked[v]){\r\n                this.dfs(G, v);\r\n                this.count++;\r\n            }\r\n        }\r\n    };\r\n    \r\n    StronglyConnectedComponents.prototype.dfs = function (G, v) {\r\n        this.marked[v] = true;\r\n        this.id[v] = this.count;\r\n        var adj_v = G.adj(v);\r\n        for (var i = 0; i < adj_v.length; ++i){\r\n            var w = adj_v[i];\r\n            if(!this.marked[w]){\r\n                this.dfs(G, w);\r\n            }\r\n        }\r\n    };\r\n    \r\n    \r\n    StronglyConnectedComponents.prototype.componentId = function(v) {\r\n        return this.id[v];\r\n    };\r\n    \r\n    StronglyConnectedComponents.prototype.componentCount = function(){\r\n        return this.count;\r\n    };\r\n    \r\n    jss.StronglyConnectedComponents = StronglyConnectedComponents;\r\n    \r\n    var KruskalMST = function(G) {\r\n        var V = G.V;\r\n        var pq = new jss.MinPQ(function(e1, e2){\r\n            return e1.weight - e2.weight;\r\n        });\r\n        for(var v = 0; v < G.V; ++v){\r\n            var adj_v = G.adj(v);\r\n            for (var i = 0; i < adj_v.length; ++i) {\r\n                var e = adj_v[i];\r\n                if(e.either() != v) {\r\n                    continue;\r\n                }\r\n                pq.enqueue(e);\r\n            }\r\n        }\r\n        \r\n        this.mst = [];\r\n        \r\n        var uf = new jss.QuickUnion(V);\r\n        while (!pq.isEmpty() && this.mst.length < V-1) {\r\n            var e = pq.delMin();\r\n            var v = e.either();\r\n            var w = e.other(v);\r\n            \r\n            if(!uf.connected(v, w)){\r\n                uf.union(v, w);\r\n                this.mst.push(e);\r\n            }\r\n        }\r\n    };\r\n    \r\n    \r\n    \r\n    jss.KruskalMST = KruskalMST;\r\n    \r\n    var LazyPrimMST = function(G) {\r\n        var V = G.V;\r\n        this.marked = [];\r\n        for( var v = 0; v < V; ++v) {\r\n            this.marked.push(false);\r\n        }\r\n        \r\n        this.pq = new jss.MinPQ(function(e1, e2){\r\n            return e1.weight - e2.weight;\r\n        });\r\n        \r\n        this.mst = [];\r\n        \r\n        this.visit(G, 0);\r\n        \r\n        while(!this.pq.isEmpty() && this.mst.length < V-1) {\r\n            var e = this.pq.delMin();\r\n            var v = e.either();\r\n            var w = e.other(v);\r\n            if(this.marked[v] && this.marked[w]) continue;\r\n            this.mst.push(e);\r\n            if(!this.marked[v]) this.visit(G, v);\r\n            if(!this.marked[w]) this.visit(G, w);\r\n        }\r\n    };\r\n    \r\n    LazyPrimMST.prototype.visit = function(G, v) {\r\n        this.marked[v]  = true;\r\n        var adj_v = G.adj(v);\r\n        for (var i = 0; i < adj_v.length; ++i) {\r\n            var e = adj_v[i];\r\n            if(!this.marked[e.other(v)]){\r\n                this.pq.enqueue(e);\r\n            }\r\n        }\r\n    };\r\n    \r\n    jss.LazyPrimMST = LazyPrimMST;\r\n    \r\n    var EagerPrimMST = function(G) {\r\n        var V = G.V;\r\n        this.pq = new jss.IndexMinPQ(V, function(e1, e2) {\r\n            return e1.weight - e2.weight;\r\n        });\r\n        this.marked = [];\r\n        for(var v = 0; v < V; ++v) {\r\n            this.marked.push(false);\r\n        }\r\n        this.mst = [];\r\n        this.visit(G, 0);\r\n        while(!this.pq.isEmpty()) {\r\n            var e = this.pq.minKey();\r\n            var w = this.pq.delMin();\r\n            \r\n            this.mst.push(e);\r\n            \r\n            if(!this.marked[w]){\r\n                this.visit(G, w);\r\n            }\r\n            \r\n        }\r\n    };\r\n    \r\n    EagerPrimMST.prototype.visit = function(G, v) {\r\n        this.marked[v]  = true;\r\n        var adj_v = G.adj(v);\r\n        for(var i = 0; i < adj_v.length; ++i) {\r\n            var e = adj_v[i];\r\n            var w = e.other(v);\r\n            if(this.marked[w]) continue;\r\n            if(this.pq.containsIndex(w)){\r\n                this.pq.decreaseKey(w, e);\r\n            } else {\r\n                this.pq.insert(w, e);\r\n            }\r\n        }\r\n    };\r\n    \r\n    jss.EagerPrimMST = EagerPrimMST;\r\n    \r\n    var Dijkstra = function(G, s) {\r\n        var V = G.V;\r\n        this.s = s;\r\n        this.marked = [];\r\n        this.edgeTo = [];\r\n        this.cost = [];\r\n        this.pq = new jss.IndexMinPQ(V, function(cost1, cost2){\r\n            return cost1, cost2;\r\n        });\r\n        \r\n        for(var v =0; v < V; ++v){\r\n            this.marked.push(false);\r\n            this.edgeTo.push(null);\r\n            this.cost.push(Number.MAX_VALUE);\r\n        }\r\n        \r\n        this.cost[s] = 0;\r\n        \r\n        this.pq.insert(s, this.cost[s]);\r\n        \r\n        while(!this.pq.isEmpty()) {\r\n            var v = this.pq.delMin();\r\n            this.marked[v] = true;\r\n            var adj_v = G.adj(v);\r\n            for(var i = 0; i < adj_v.length; ++i) {\r\n                var e = adj_v[i];\r\n                this.relax(e);\r\n            }\r\n        }\r\n        \r\n    };\r\n    \r\n        \r\n    \r\n    \r\n    Dijkstra.prototype.relax = function(e) {\r\n        \r\n        var v = e.from();\r\n        var w = e.to();\r\n        \r\n        if(this.cost[w] > this.cost[v] + e.weight) {\r\n            this.cost[w] = this.cost[v] + e.weight;\r\n            this.edgeTo[w] = e;\r\n            if(this.pq.containsIndex(w)){\r\n                this.pq.decreaseKey(w, this.cost[w]);\r\n            } else {\r\n                this.pq.insert(w, this.cost[w]);\r\n            }\r\n        }\r\n    };\r\n    \r\n\r\n    \r\n    Dijkstra.prototype.hasPathTo = function(v) {\r\n        return this.marked[v];  \r\n    };\r\n\r\n    \r\n    Dijkstra.prototype.pathTo = function(v) {\r\n        var path = new jss.Stack();\r\n        for(var x = v; x != this.s; x = this.edgeTo[x].other(x)) {\r\n            path.push(this.edgeTo[x]);\r\n        }  \r\n        return path.toArray();\r\n    };\r\n    \r\n    Dijkstra.prototype.distanceTo = function(v) {\r\n        return this.cost[v];  \r\n    };\r\n    \r\n    \r\n    jss.Dijkstra = Dijkstra;\r\n    \r\n    var BellmanFord = function(G, s) {\r\n        var V = G.V;\r\n        this.s = s;\r\n        this.marked = [];\r\n        this.edgeTo = [];\r\n        this.cost = [];\r\n        \r\n        \r\n        for(var v =0; v < V; ++v){\r\n            this.marked.push(false);\r\n            this.edgeTo.push(null);\r\n            this.cost.push(Number.MAX_VALUE);\r\n        }\r\n        \r\n        this.cost[s] = 0;\r\n        this.marked[s] = true;\r\n        \r\n        for(var j = 0; j < V; ++j) {\r\n            for(var v = 0; v < V; ++v){\r\n                var adj_v = G.adj(v);\r\n                for(var i = 0; i < adj_v.length; ++i) {\r\n                    var e = adj_v[i];\r\n                    this.relax(e);\r\n                }\r\n            }\r\n        }\r\n        \r\n    };\r\n    \r\n    BellmanFord.prototype.relax = function(e) {\r\n        \r\n        var v = e.from();\r\n        var w = e.to();\r\n        \r\n        if(this.cost[w] > this.cost[v] + e.weight) {\r\n            this.cost[w] = this.cost[v] + e.weight;\r\n            this.marked[w] = true;\r\n            this.edgeTo[w] = e;\r\n        }\r\n    };\r\n    \r\n    BellmanFord.prototype.hasPathTo = function(v) {\r\n        return this.marked[v];  \r\n    };\r\n\r\n    \r\n    BellmanFord.prototype.pathTo = function(v) {\r\n        var path = new jss.Stack();\r\n        for(var x = v; x != this.s; x = this.edgeTo[x].other(x)) {\r\n            path.push(this.edgeTo[x]);\r\n        }  \r\n        return path.toArray();\r\n    };\r\n    \r\n    BellmanFord.prototype.distanceTo = function(v) {\r\n        return this.cost[v];  \r\n    };\r\n    \r\n    jss.BellmanFord = BellmanFord;\r\n    \r\n    var TopologicalSortShortestPaths = function(G, s) {\r\n        var V = G.V;\r\n        this.s = s;\r\n        this.marked = [];\r\n        this.edgeTo = [];\r\n        this.cost = [];\r\n        \r\n        \r\n        for(var v =0; v < V; ++v){\r\n            this.marked.push(false);\r\n            this.edgeTo.push(null);\r\n            this.cost.push(Number.MAX_VALUE);\r\n        }\r\n        \r\n        this.cost[s] = 0;\r\n        this.marked[s] = true;\r\n        \r\n        var order = new jss.TopologicalSort(G.toDiGraph()).order();\r\n        \r\n        \r\n        for(var j = 0; j < order.length; ++j){\r\n            var v = order[j];\r\n            var adj_v = G.adj(v);\r\n            for(var i = 0; i < adj_v.length; ++i) {\r\n                var e = adj_v[i];\r\n                this.relax(e);\r\n            }\r\n        }\r\n        \r\n        \r\n    };\r\n    \r\n    TopologicalSortShortestPaths.prototype.relax = function(e) {\r\n        \r\n        var v = e.from();\r\n        var w = e.to();\r\n        \r\n        if(this.cost[w] > this.cost[v] + e.weight) {\r\n            this.cost[w] = this.cost[v] + e.weight;\r\n            this.marked[w] = true;\r\n            this.edgeTo[w] = e;\r\n        }\r\n    };\r\n    \r\n    TopologicalSortShortestPaths.prototype.hasPathTo = function(v) {\r\n        return this.marked[v];  \r\n    };\r\n\r\n    \r\n    TopologicalSortShortestPaths.prototype.pathTo = function(v) {\r\n        var path = new jss.Stack();\r\n        for(var x = v; x != this.s; x = this.edgeTo[x].other(x)) {\r\n            path.push(this.edgeTo[x]);\r\n        }  \r\n        return path.toArray();\r\n    };\r\n    \r\n    TopologicalSortShortestPaths.prototype.distanceTo = function(v) {\r\n        return this.cost[v];  \r\n    };\r\n    \r\n    jss.TopologicalSortShortestPaths = TopologicalSortShortestPaths;\r\n    \r\n    var FordFulkerson = function(G, s, t) {\r\n        this.value = 0;\r\n        var V = G.V;\r\n        var bottle = Number.MAX_VALUE;\r\n        this.marked = null;\r\n        this.edgeTo = null;\r\n        this.s = s;\r\n        this.t = t;\r\n        while(this.hasAugmentedPath(G)){\r\n            \r\n            for(var x = this.t; x != this.s; x = this.edgeTo[x].other(x)) {\r\n                bottle = Math.min(bottle, this.edgeTo[x].residualCapacityTo(x));\r\n            }\r\n            \r\n            for(var x = this.t; x != this.s; x = this.edgeTo[x].other(x)) {\r\n                this.edgeTo[x].addResidualFlowTo(x, bottle);\r\n            }\r\n            \r\n            \r\n            this.value += bottle;\r\n        }\r\n    };\r\n    \r\n    FordFulkerson.prototype.hasAugmentedPath = function(G) {\r\n        var V = G.V;\r\n        this.marked = [];\r\n        this.edgeTo = [];\r\n        for(var v = 0; v < V; ++v) {\r\n            this.marked.push(false);\r\n            this.edgeTo.push(null);\r\n        }\r\n        \r\n        var queue = new jss.Queue();\r\n        queue.enqueue(this.s);\r\n        \r\n        this.marked[this.s] = true;\r\n        while(!queue.isEmpty()){\r\n            var v = queue.dequeue();\r\n            var adj_v = G.adj(v);\r\n            \r\n            for (var i = 0; i < adj_v.length; ++i) {\r\n                var e = adj_v[i];\r\n                var w = e.other(v);\r\n                if(!this.marked[w] && e.residualCapacityTo(w) > 0){\r\n                    this.edgeTo[w] = e;\r\n                    this.marked[w] = true;\r\n                    if(w == this.t){\r\n                        return true;\r\n                    }\r\n                    \r\n                    queue.enqueue(w);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    };\r\n    \r\n    FordFulkerson.prototype.minCut = function(G) {\r\n        var cuts = [];\r\n        var V = G.V;\r\n        for(var v = 0; v < V; ++v){\r\n            var adj_v = G.adj(v);\r\n            for(var i = 0; i < adj_v.length; ++i) {\r\n                var e = adj_v[i];\r\n                if(e.from() == v && e.residualCapacityTo(e.other(v)) == 0) {\r\n                    cuts.push(e);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return cuts;\r\n    };\r\n\r\n    jss.FordFulkerson = FordFulkerson;\r\n})(jsgraphs);\r\n\r\nvar module = module || {};\r\nif(module) {\r\n\tmodule.exports = jsgraphs;\r\n}\n\n//# sourceURL=webpack:///./node_modules/js-graph-algorithms/src/jsgraphs.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var jsgraphs = __webpack_require__(/*! js-graph-algorithms/src/jsgraphs */ \"./node_modules/js-graph-algorithms/src/jsgraphs.js\");\r\n\r\n\r\n\r\n///kuruksal\r\nvar g;\r\n\r\ndocument.getElementById('numc').onclick = function(){\r\n    var numv = document.getElementById('numv').value\r\n     g = new jsgraphs.WeightedGraph(numv);\r\n    console.log(numv)\r\n}\r\n\r\ndocument.getElementById('addedge').onclick = function(){\r\n    var to = document.getElementById('tov').value\r\n    var from = document.getElementById('fromv').value\r\n    var dist = document.getElementById('dist').value\r\n    g.addEdge(new jsgraphs.Edge(from, to, dist));\r\n}\r\n\r\ndocument.getElementById('drowk').onclick = function(){\r\n    var kruskal = new jsgraphs.KruskalMST(g); \r\n    var mst = kruskal.mst;\r\n    \r\n\r\n    var g_nodes = [];\r\n    var g_edges = [];\r\n    for(var v=0; v < g.V; ++v){\r\n        g.node(v).label = 'Node ' + v; // assigned 'Node {v}' as label for node v\r\n        g_nodes.push({\r\n           id: v,\r\n           label: g.node(v).label\r\n        });\r\n    }\r\n    \r\n    for(var i=0; i < mst.length; ++i) {\r\n        var e = mst[i];\r\n        var v = e.either();\r\n        var w = e.other(v);\r\n        e.highlighted = true;\r\n        console.log('(' + v + ', ' + w + '): ' + e.weight);\r\n        g_edges.push({\r\n            from: v,\r\n            to: w,\r\n            length: e.weight,\r\n            label: '' + e.weight,\r\n            color: '#ff0000',\r\n            value: 2\r\n        });\r\n    }\r\n    \r\n    for(var v = 0; v < g.V; ++v) {\r\n        \r\n        var adj_v = g.adj(v);\r\n        for(var i = 0; i < adj_v.length; ++i) {\r\n            var e = adj_v[i];\r\n            var w = e.other(v);\r\n            if(w > v) continue; // make sure only one edge between w and v since the graph is undirected\r\n            if(e.highlighted) continue;\r\n            \r\n            g_edges.push({\r\n                from: v,\r\n                to: w,\r\n                length: e.weight,\r\n                label: '' + e.weight\r\n            });\r\n        };\r\n    }\r\n\r\n    console.log(g.V); // display 6, which is the number of vertices in g\r\n    console.log(g.adj(0)); // display [5, 1, 2], which is the adjacent list to vertex 0\r\n    \r\n    var nodes = new vis.DataSet(g_nodes);\r\n\r\n    // create an array with edges\r\n    var edges = new vis.DataSet(g_edges);\r\n\r\n    // create a network\r\n    var container = document.getElementById('mynetwork');\r\n    var data = {\r\n        nodes: nodes,\r\n        edges: edges\r\n    };\r\n    var options = {};\r\n    var network = new vis.Network(container, data, options);\r\n}\r\n\r\ndocument.getElementById('drowp').onclick = function(){\r\n    var prim = new jsgraphs.EagerPrimMST(g)\r\n    var mst2 = prim.mst;\r\n    \r\n\r\n    var g_nodes = [];\r\n    var g_edges = [];\r\n    for(var v=0; v < g.V; ++v){\r\n        g.node(v).label = 'Node ' + v; // assigned 'Node {v}' as label for node v\r\n        g_nodes.push({\r\n           id: v,\r\n           label: g.node(v).label\r\n        });\r\n    }\r\n    \r\n    for(var i=0; i < mst.length; ++i) {\r\n        var e = mst[i];\r\n        var v = e.either();\r\n        var w = e.other(v);\r\n        e.highlighted = true;\r\n        console.log('(' + v + ', ' + w + '): ' + e.weight);\r\n        g_edges.push({\r\n            from: v,\r\n            to: w,\r\n            length: e.weight,\r\n            label: '' + e.weight,\r\n            color: '#ff0000',\r\n            value: 2\r\n        });\r\n    }\r\n    \r\n    for(var v = 0; v < g.V; ++v) {\r\n        \r\n        var adj_v = g.adj(v);\r\n        for(var i = 0; i < adj_v.length; ++i) {\r\n            var e = adj_v[i];\r\n            var w = e.other(v);\r\n            if(w > v) continue; // make sure only one edge between w and v since the graph is undirected\r\n            if(e.highlighted) continue;\r\n            \r\n            g_edges.push({\r\n                from: v,\r\n                to: w,\r\n                length: e.weight,\r\n                label: '' + e.weight\r\n            });\r\n        };\r\n    }\r\n\r\n    console.log(g.V); // display 6, which is the number of vertices in g\r\n    console.log(g.adj(0)); // display [5, 1, 2], which is the adjacent list to vertex 0\r\n    \r\n    var nodes = new vis.DataSet(g_nodes);\r\n\r\n    // create an array with edges\r\n    var edges = new vis.DataSet(g_edges);\r\n\r\n    // create a network\r\n    var container = document.getElementById('mynetwork');\r\n    var data = {\r\n        nodes: nodes,\r\n        edges: edges\r\n    };\r\n    var options = {};\r\n    var network = new vis.Network(container, data, options);\r\n}\r\n    \r\n    \r\n\r\n    \r\n\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });